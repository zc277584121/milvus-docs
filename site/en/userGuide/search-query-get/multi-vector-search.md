---
id: multi-vector-search.md
order: 2
summary: This guide demonstrates how to perform hybrid search in Milvus and understand the reranking of results.
title: Hybrid Search
---

# Hybrid Searchâ€‹

Hybrid Search refers to a search method that conducts multiple ANN searches simultaneously, reranks multiple sets of results from these ANN searches, and ultimately returns a single set of results. Using Hybrid Search can enhance the search accuracy. Zilliz supports conducting Hybrid Search on a collection with multiple vector fields. â€‹

Hybrid Search is most commonly used in scenarios including sparse-dense vector searches and multimodal searches. This guide will demonstrate how to conduct a Hybrid Search in Zilliz with a specific example.â€‹

## Scenariosâ€‹{#scenariosâ€‹}

Hybrid Search is suitable for the following two scenarios:â€‹

### Sparse-Dense Vector Searchâ€‹{#sparse-dense-vector-searchâ€‹}

Different types of vectors can represent different information, and using various embedding models can more comprehensively represent different features and aspects of the data. For example, using different embedding models for the same sentence can generate a dense vector to represent the semantic meaning and a sparse vector to represent the word frequency in the sentence.â€‹

- **Sparse vectors:** Sparse vectors are characterized by their high vector dimensionality and the presence of few non-zero values. This structure makes them particularly well-suited for traditional information retrieval applications. In most cases, the number of dimensions used in sparse vectors correspond to different tokens across one or more languages. Each dimension is assigned a value that indicates the relative importance of that token within the document. This layout proves advantageous for tasks that involve keyword matching.â€‹

- **Dense vectors:** Dense vectors are embeddings derived from neural networks. When arranged in an ordered array, these vectors capture the semantic essence of the input text. Note that dense vectors are not limited to text processing; they are also extensively used in computer vision to represent the semantics of visual data. These dense vectors, usually generated by text embedding models, are characterized by most or all elements being non-zero. Thus, dense vectors are particularly effective for semantic search applications, as they can return the most similar results based on vector distance even in the absence of exact keyword matches. This capability allows for more nuanced and context-aware search results, often capturing relationships between concepts that might be missed by keyword-based approaches.â€‹

For more details, refer to [â€‹Sparse Vector](https://zilliverse.feishu.cn/wiki/JbPDwHqd0iZZSuk5tYicGqKbn9c) and [â€‹Dense Vector](https://zilliverse.feishu.cn/wiki/ARalwpaVDiCwDZkoSHtcPNgXnRg).â€‹

### Multimodal Searchâ€‹{#multimodal-searchâ€‹}

Multimodal search refers to the similarity search of unstructured data across multiple modalities (such as images, videos, audio, text, etc). For instance, a person can be represented using various modalities of data such as fingerprints, voiceprints, and facial features. Hybrid Search supports multiple searches simultaneously. For example searching a person with both similar fingerprints and voiceprints.â€‹

## Workflowâ€‹{#workflowâ€‹}

The main workflow for conducting a Hybrid Search is as follows:â€‹

1. Generate dense vectors through embedding models like [BERT](https://zilliz.com/learn/explore-colbert-token-level-embedding-and-ranking-model-for-similarity-search#A-Quick-Recap-of-BERT) and [Transformers](https://zilliz.com/learn/NLP-essentials-understanding-transformers-in-AI).â€‹

2. Generate sparse vectors through embedding models like [BM25](https://zilliz.com/learn/mastering-bm25-a-deep-dive-into-the-algorithm-and-application-in-milvus), [BGE-M3](https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings#BGE-M3), [SPLADE](https://zilliz.com/learn/bge-m3-and-splade-two-machine-learning-models-for-generating-sparse-embeddings#SPLADE), etc.â€‹

3. Create a collection in Zilliz and define the collection schema which includes both dense and sparse vector fields.â€‹

4. Insert sparse-dense vectors into the collection just created in the previous step.â€‹

5. Conduct a Hybrid Search: ANN Search on dense vectors will return a set of top-K most similar results, and text match on sparse vectors will also return a set of top-K results.â€‹

6. Normalization: Normalize the scores of the two sets of top-K results, converting the scores to a range between [0,1].â€‹

7. Choose an appropriate reranking strategy to merge and rerank the two sets of top-K results and ultimately return a final set of top-K results.â€‹

![NrT9doIXloMOEexzEcacZ3jKn3b](è¯·æ‰‹åŠ¨ä¸‹è½½å›¾ç‰‡å¹¶æ›¿æ¢)

## Examplesâ€‹{#examplesâ€‹}

This section will use a specific example to illustrate how to conduct a Hybrid Search on sparse-dense vectors to enhance the accuracy of text searches.â€‹

### Create a collection with multiple vector fieldsâ€‹{#create-a-collection-with-multiple-vector-fieldsâ€‹}

The process of creating a collection includes three parts: defining the collection schema, configuring the index parameters, and creating the collection.â€‹

#### Define schemaâ€‹{#define-schemaâ€‹}

In this example, multiple vector fields need to be defined within the collection schema. Currently, each collection can include up to 4 vector fields by default. But you can also modify the value of  [`proxy.maxVectorFieldNum`](https://milvus.io/docs/configure_proxy.md#proxymaxVectorFieldNum)  to include up to 10 vector fields in a collection as needed.â€‹

The following example defines a collection schema, where `dense` and `sparse` are the two vector fields:â€‹

- `id`: This field serves as the primary key for storing text IDs. The data type of this field is INT64.â€‹

- `text`: This field is used for storing textual content. The data type of this field is VARCHAR, with a maximum length of 1000 characters.â€‹

- `dense`: This field is used to store the dense vectors of the texts. The data type of this field is FLOAT_VECTOR, with a vector dimension of 768.â€‹

- `sparse`: This field is used to store the sparse vectors of the texts. The data type of this field is SPARSE_FLOAT_VECTOR.â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
# Create a collection in customized setup modeâ€‹
from pymilvus import (â€‹
    MilvusClient, DataTypeâ€‹
)â€‹
â€‹
client = MilvusClient(â€‹
    uri="http://localhost:19530",â€‹
    token="root:Milvus"â€‹
)â€‹
â€‹
# Create schemaâ€‹
schema = MilvusClient.create_schema(â€‹
    auto_id=False,â€‹
    enable_dynamic_field=True,â€‹
)â€‹
# Add fields to schemaâ€‹
schema.add_field(field_name="id", datatype=DataType.INT64, is_primary=True)â€‹
schema.add_field(field_name="text", datatype=DataType.VARCHAR, max_length=1000)â€‹
schema.add_field(field_name="sparse", datatype=DataType.SPARSE_FLOAT_VECTOR)â€‹
schema.add_field(field_name="dense", datatype=DataType.FLOAT_VECTOR, dim=5)â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
import io.milvus.v2.client.ConnectConfig;â€‹
import io.milvus.v2.client.MilvusClientV2;â€‹
import io.milvus.v2.common.DataType;â€‹
import io.milvus.v2.service.collection.request.AddFieldReq;â€‹
import io.milvus.v2.service.collection.request.CreateCollectionReq;â€‹
â€‹
MilvusClientV2 client = new MilvusClientV2(ConnectConfig.builder()â€‹
        .uri("http://localhost:19530")â€‹
        .token("root:Milvus")â€‹
        .build());â€‹
â€‹
CreateCollectionReq.CollectionSchema schema = client.createSchema();â€‹
schema.addField(AddFieldReq.builder()â€‹
        .fieldName("id")â€‹
        .dataType(DataType.Int64)â€‹
        .isPrimaryKey(true)â€‹
        .autoID(false)â€‹
        .build());â€‹
â€‹
schema.addField(AddFieldReq.builder()â€‹
        .fieldName("text")â€‹
        .dataType(DataType.VarChar)â€‹
        .maxLength(1000)â€‹
        .build());â€‹
â€‹
schema.addField(AddFieldReq.builder()â€‹
        .fieldName("dense")â€‹
        .dataType(DataType.FloatVector)â€‹
        .dimension(768)â€‹
        .build());â€‹
â€‹
schema.addField(AddFieldReq.builder()â€‹
        .fieldName("sparse")â€‹
        .dataType(DataType.SparseFloatVector)â€‹
        .build());â€‹

```

</TabItem>

<TabItem value="Go" label="go">

```Go
// WIPâ€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
import { MilvusClient, DataType } from "@zilliz/milvus2-sdk-node";â€‹
â€‹
const address = "http://localhost:19530";â€‹
const token = "root:Milvus";â€‹
const client = new MilvusClient({address, token});â€‹
â€‹
// Create a collection in customized setup modeâ€‹
// Define fieldsâ€‹
const fields = [â€‹
    {â€‹
        name: "id",â€‹
        data_type: DataType.Int64,â€‹
        is_primary_key: true,â€‹
        auto_id: falseâ€‹
    },â€‹
    {â€‹
        name: "text",â€‹
        data_type: DataType.VarChar,â€‹
        max_length: 1000â€‹
    },â€‹
    {â€‹
        name: "sparse",â€‹
        data_type: DataType.SPARSE_FLOAT_VECTORâ€‹
    },â€‹
    {â€‹
        name: "dense",â€‹
        data_type: DataType.FloatVector,â€‹
        dim: 768â€‹
    }â€‹
]â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
export schema='{â€‹
        "autoId": false,â€‹
        "enabledDynamicField": true,â€‹
        "fields": [â€‹
            {â€‹
                "fieldName": "id",â€‹
                "dataType": "Int64",â€‹
                "isPrimary": trueâ€‹
            },â€‹
            {â€‹
                "fieldName": "text",â€‹
                "dataType": "VarChar",â€‹
                "elementTypeParams": {â€‹
                    "max_length": 1000â€‹
                }â€‹
            },â€‹
            {â€‹
                "fieldName": "sparse",â€‹
                "dataType": "SparseFloatVector"â€‹
            },â€‹
            {â€‹
                "fieldName": "dense",â€‹
                "dataType": "FloatVector",â€‹
                "elementTypeParams": {â€‹
                    "dim": "768"â€‹
                }â€‹
            }â€‹
        ]â€‹
    }'â€‹

```

</TabItem></Tabs>

During sparse vector searches, you can simplify the process of generating sparse embedding vectors by leveraging Full Text Search capabilities. For more details, see [â€‹Full Text Search](https://zilliverse.feishu.cn/wiki/RQTRwhOVPiwnwokqr4scAtyfnBf).â€‹

#### Create indexâ€‹{#create-indexâ€‹}

After defining the collection schema, it is necessary to set up the vector indexes and the similarity metrics. In this example, an IVF_FLAT index is created for the dense vector field `dense`, and a SPARSE_INVERTED_INDEX is created for the sparse vector field `sparse`. To learn about the types of indexes supported, see [â€‹Index Explained](https://zilliverse.feishu.cn/wiki/JGHqwChJxicxp9kJJf9cgeB2nvg).â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
from pymilvus import MilvusClientâ€‹
â€‹
# Prepare index parametersâ€‹
index_params = client.prepare_index_params()â€‹
â€‹
# Add indexesâ€‹
index_params.add_index(â€‹
    field_name="dense",â€‹
    index_name="dense_index",â€‹
    index_type="IVF_FLAT",â€‹
    metric_type="IP",â€‹
    params={"nlist": 128},â€‹
)â€‹
â€‹
index_params.add_index(â€‹
    field_name="sparse",â€‹
    index_name="sparse_index",â€‹
    index_type="SPARSE_INVERTED_INDEX",  # Index type for sparse vectorsâ€‹
    metric_type="IP",  # Currently, only IP (Inner Product) is supported for sparse vectorsâ€‹
    params={"drop_ratio_build": 0.2},  # The ratio of small vector values to be dropped during indexingâ€‹
)â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
import io.milvus.v2.common.IndexParam;â€‹
import java.util.*;â€‹
â€‹
Map<String, Object> denseParams = new HashMap<>();â€‹
denseParams.put("nlist", 128);â€‹
IndexParam indexParamForDenseField = IndexParam.builder()â€‹
        .fieldName("dense")â€‹
        .indexName("dense_index")â€‹
        .indexType(IndexParam.IndexType.IVF_FLAT)â€‹
        .metricType(IndexParam.MetricType.IP)â€‹
        .extraParams(denseParams)â€‹
        .build();â€‹
â€‹
Map<String, Object> sparseParams = new HashMap<>();â€‹
sparseParams.put("drop_ratio_build", 0.2);â€‹
IndexParam indexParamForSparseField = IndexParam.builder()â€‹
        .fieldName("sparse")â€‹
        .indexName("sparse_index")â€‹
        .indexType(IndexParam.IndexType.SPARSE_INVERTED_INDEX)â€‹
        .metricType(IndexParam.MetricType.IP)â€‹
        .extraParams(sparseParams)â€‹
        .build();â€‹
â€‹
List<IndexParam> indexParams = new ArrayList<>();â€‹
indexParams.add(indexParamForDenseField);â€‹
indexParams.add(indexParamForSparseField);â€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
const index_params = [{â€‹
    field_name: "dense",â€‹
    index_type: "IVF_FLAT",â€‹
    metric_type: "IP"â€‹
},{â€‹
    field_name: "sparse",â€‹
    index_type: "SPARSE_INVERTED_INDEX",â€‹
    metric_type: "IP"â€‹
}]â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
export indexParams='[â€‹
        {â€‹
            "fieldName": "dense",â€‹
            "metricType": "IP",â€‹
            "indexName": "dense_index",â€‹
            "indexType":"IVF_FLAT",â€‹
            "params":{"nlist":128}â€‹
        },â€‹
        {â€‹
            "fieldName": "sparse",â€‹
            "metricType": "IP",â€‹
            "indexName": "sparse_index",â€‹
            "indexType": "SPARSE_INVERTED_INDEX"â€‹
        }â€‹
    ]'â€‹

```

</TabItem></Tabs>

#### Create collectionâ€‹{#create-collectionâ€‹}

Create a collection named `demo` with the collection schema and indexes configured in the previous two steps.â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
from pymilvus import MilvusClientâ€‹
â€‹
client.create_collection(â€‹
    collection_name="hybrid_search_collection",â€‹
    schema=schema,â€‹
    index_params=index_paramsâ€‹
)â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
CreateCollectionReq createCollectionReq = CreateCollectionReq.builder()â€‹
        .collectionName("hybrid_search_collection")â€‹
        .collectionSchema(schema)â€‹
        .indexParams(indexParams)â€‹
        .build();â€‹
client.createCollection(createCollectionReq);â€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
res = await client.createCollection({â€‹
    collection_name: "hybrid_search_collection",â€‹
    fields: fields,â€‹
    index_params: index_params,â€‹
})â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
export CLUSTER_ENDPOINT="http://localhost:19530"â€‹
export TOKEN="root:Milvus"â€‹
â€‹
curl --request POST \â€‹
--url "${CLUSTER_ENDPOINT}/v2/vectordb/collections/create" \â€‹
--header "Authorization: Bearer ${TOKEN}" \â€‹
--header "Content-Type: application/json" \â€‹
-d "{â€‹
    \"collectionName\": \"hybrid_search_collection\",â€‹
    \"schema\": $schema,â€‹
    \"indexParams\": $indexParamsâ€‹
}"â€‹

```

</TabItem></Tabs>

### Insert dataâ€‹{#insert-dataâ€‹}

Insert the sparse-dense vectors into the the collection `demo`.â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
from pymilvus import MilvusClientâ€‹
â€‹
data=[â€‹
    {"id": 0, "text": "Artificial intelligence was founded as an academic discipline in 1956.", "sparse":{9637: 0.30856525997853057, 4399: 0.19771651149001523, ...}, "dense": [0.3580376395471989, -0.6023495712049978, 0.18414012509913835, ...]},â€‹
    {"id": 1, "text": "Alan Turing was the first person to conduct substantial research in AI.", "sparse":{6959: 0.31025067641541815, 1729: 0.8265339135915016, ...}, "dense": [0.19886812562848388, 0.06023560599112088, 0.6976963061752597, ...]},â€‹
    {"id": 2, "text": "Born in Maida Vale, London, Turing was raised in southern England.", "sparse":{1220: 0.15303302147479103, 7335: 0.9436728846033107, ...}, "dense": [0.43742130801983836, -0.5597502546264526, 0.6457887650909682, ...]}â€‹
â€‹
res = client.insert(â€‹
    collection_name="hybrid_search_collection",â€‹
    data=dataâ€‹
)â€‹
â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
import com.google.gson.Gson;â€‹
import com.google.gson.JsonObject;â€‹
import io.milvus.v2.service.vector.request.InsertReq;â€‹
â€‹
Gson gson = new Gson();â€‹
JsonObject row1 = new JsonObject();â€‹
row1.addProperty("id", 1);â€‹
row1.addProperty("text", "Artificial intelligence was founded as an academic discipline in 1956.");â€‹
row1.add("dense", gson.toJsonTree(dense1));â€‹
row1.add("sparse", gson.toJsonTree(sparse1));â€‹
â€‹
JsonObject row2 = new JsonObject();â€‹
row2.addProperty("id", 2);â€‹
row2.addProperty("text", "Alan Turing was the first person to conduct substantial research in AI.");â€‹
row2.add("dense", gson.toJsonTree(dense2));â€‹
row2.add("sparse", gson.toJsonTree(sparse2));â€‹
â€‹
JsonObject row3 = new JsonObject();â€‹
row3.addProperty("id", 3);â€‹
row3.addProperty("text", "Born in Maida Vale, London, Turing was raised in southern England.");â€‹
row3.add("dense", gson.toJsonTree(dense3));â€‹
row3.add("sparse", gson.toJsonTree(sparse3));â€‹
â€‹
List<JsonObject> data = Arrays.asList(row1, row2, row3);â€‹
InsertReq insertReq = InsertReq.builder()â€‹
        .collectionName("hybrid_search_collection")â€‹
        .data(data)â€‹
        .build();â€‹
â€‹
InsertResp insertResp = client.insert(insertReq);â€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
const { MilvusClient, DataType } = require("@zilliz/milvus2-sdk-node")â€‹
â€‹
var data = [â€‹
    {id: 0, text: "Artificial intelligence was founded as an academic discipline in 1956.", sparse:[9637: 0.30856525997853057, 4399: 0.19771651149001523, ...] , dense: [0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592]},â€‹
    {id: 1, text: "Alan Turing was the first person to conduct substantial research in AI.", sparse:[6959: 0.31025067641541815, 1729: 0.8265339135915016, ...] , dense: [0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104]},â€‹
    {id: 2, text: "Born in Maida Vale, London, Turing was raised in southern England." , sparse:[1220: 0.15303302147479103, 7335: 0.9436728846033107, ...] , dense: [0.43742130801983836, -0.5597502546264526, 0.6457887650909682, 0.7894058910881185, 0.20785793220625592]}       â€‹
]â€‹
â€‹
var res = await client.insert({â€‹
    collection_name: "hybrid_search_collection",â€‹
    data: data,â€‹
})â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
curl --request POST \â€‹
--url "${CLUSTER_ENDPOINT}/v2/vectordb/entities/insert" \â€‹
--header "Authorization: Bearer ${TOKEN}" \â€‹
--header "Content-Type: application/json" \â€‹
-d '{â€‹
    "data": [â€‹
        {"id": 0, "text": "Artificial intelligence was founded as an academic discipline in 1956.", "sparse":{"9637": 0.30856525997853057, "4399": 0.19771651149001523}, "dense": [0.3580376395471989, -0.6023495712049978, 0.18414012509913835, ...]},â€‹
        {"id": 1, "text": "Alan Turing was the first person to conduct substantial research in AI.", "sparse":{"6959": 0.31025067641541815, "1729": 0.8265339135915016}, "dense": [0.19886812562848388, 0.06023560599112088, 0.6976963061752597, ...]},â€‹
        {"id": 2, "text": "Born in Maida Vale, London, Turing was raised in southern England.", "sparse":{"1220": 0.15303302147479103, "7335": 0.9436728846033107}, "dense": [0.43742130801983836, -0.5597502546264526, 0.6457887650909682, ...]}â€‹
    ],â€‹
    "collectionName": "hybrid_search_collection"â€‹
}'â€‹

```

</TabItem></Tabs>

### Create multiple AnnSearchRequest instancesâ€‹{#create-multiple-annsearchrequest-instancesâ€‹}

Hybrid Search is implemented by creating multiple `AnnSearchRequest` in the `hybrid_search()` function, where each `AnnSearchRequest` represents a basic ANN search request for a specific vector field. Therefore, before conducting a Hybrid Search, it is necessary to create an `AnnSearchRequest` for each vector field.â€‹

:::info[ğŸ“˜ Notesâ€‹]

In Hybrid Search, each `AnnSearchRequest` supports only one query vector.â€‹

:::

Suppose the query text "Who started AI research?" has already been converted into sparse and dense vectors. Based on this, two `AnnSearchRequest` search requests are created for the `sparse` and `dense` vector fields respectively, as shown in the following example.â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
from pymilvus import AnnSearchRequestâ€‹
â€‹
query_dense_vector = [0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592]â€‹
â€‹
search_param_1 = {â€‹
    "data": [query_dense_vector],â€‹
    "anns_field": "dense",â€‹
    "param": {â€‹
        "metric_type": "IP",â€‹
        "params": {"nprobe": 10}â€‹
    },â€‹
    "limit": 2â€‹
}â€‹
request_1 = AnnSearchRequest(**search_param_1)â€‹
â€‹
query_sparse_vector = {3573: 0.34701499565746674}, {5263: 0.2639375518635271}â€‹
search_param_2 = {â€‹
    "data": [query_sparse_vector],â€‹
    "anns_field": "sparse",â€‹
    "param": {â€‹
        "metric_type": "IP",â€‹
        "params": {"drop_ratio_build": 0.2}â€‹
    },â€‹
    "limit": 2â€‹
}â€‹
request_2 = AnnSearchRequest(**search_param_2)â€‹
â€‹
reqs = [request_1, request_2]â€‹
â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
import io.milvus.v2.service.vector.request.AnnSearchReq;â€‹
import io.milvus.v2.service.vector.request.data.BaseVector;â€‹
import io.milvus.v2.service.vector.request.data.FloatVec;â€‹
import io.milvus.v2.service.vector.request.data.SparseFloatVec;â€‹
â€‹
float[] dense = new float[]{-0.0475336798f,  0.0521207601f,  0.0904406682f, ...};â€‹
SortedMap<Long, Float> sparse = new TreeMap<Long, Float>() {{â€‹
    put(3573L, 0.34701499f);â€‹
    put(5263L, 0.263937551f);â€‹
    ...â€‹
}};â€‹
â€‹
â€‹
List<BaseVector> queryDenseVectors = Collections.singletonList(new FloatVec(dense));â€‹
List<BaseVector> querySparseVectors = Collections.singletonList(new SparseFloatVec(sparse));â€‹
â€‹
List<AnnSearchReq> searchRequests = new ArrayList<>();â€‹
searchRequests.add(AnnSearchReq.builder()â€‹
        .vectorFieldName("dense")â€‹
        .vectors(queryDenseVectors)â€‹
        .metricType(IndexParam.MetricType.IP)â€‹
        .params("{\"nprobe\": 10}")â€‹
        .topK(2)â€‹
        .build());â€‹
searchRequests.add(AnnSearchReq.builder()â€‹
        .vectorFieldName("sparse")â€‹
        .vectors(querySparseVectors)â€‹
        .metricType(IndexParam.MetricType.IP)â€‹
        .params("{\"drop_ratio_build\": 0.2}")â€‹
        .topK(2)â€‹
        .build());â€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
const search_param_1 = {â€‹
    "data": query_vector, â€‹
    "anns_field": "dense", â€‹
    "param": {â€‹
        "metric_type": "IP", // å‚æ•°å€¼éœ€è¦ä¸ Collection Schema ä¸­å®šä¹‰çš„ä¿æŒä¸€è‡´â€‹
        "params": {"nprobe": 10}â€‹
    },â€‹
    "limit": 2 // AnnSearchRequest è¿”è¿˜çš„æœç´¢ç»“æœæ•°é‡â€‹
}â€‹
â€‹
const search_param_2 = {â€‹
    "data": query_sparse_vector, â€‹
    "anns_field": "sparse", â€‹
    "param": {â€‹
        "metric_type": "IP", // å‚æ•°å€¼éœ€è¦ä¸ Collection Schema ä¸­å®šä¹‰çš„ä¿æŒä¸€è‡´â€‹
        "params": {"drop_ratio_build": 0.2}â€‹
    },â€‹
    "limit": 2 // AnnSearchRequest è¿”è¿˜çš„æœç´¢ç»“æœæ•°é‡â€‹
}â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
export req='[â€‹
    {â€‹
        "data": [[0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592,....]],â€‹
        "annsField": "dense",â€‹
        "params": {â€‹
            "params": {â€‹
                "nprobe": 10â€‹
             }â€‹
        },â€‹
        "limit": 2â€‹
    },â€‹
    {â€‹
        "data": [{"3573": 0.34701499565746674}, {"5263": 0.2639375518635271}],â€‹
        "annsField": "sparse",â€‹
        "params": {â€‹
            "params": {â€‹
                "drop_ratio_build": 0.2â€‹
             }â€‹
        },â€‹
        "limit": 2â€‹
    }â€‹
 ]'â€‹

```

</TabItem></Tabs>

Since the parameter `limit` is set to 2, each `AnnSearchRequest` returns 2 search results. In this example, 2 `AnnSearchRequest` are created, therefore a total of 4 search results will be returned.â€‹

### Configure a reranking strategyâ€‹{#configure-a-reranking-strategyâ€‹}

To merge and rerank the two sets of ANN search results, it is necessary to select an appropriate reranking strategy. Zilliz supports two types of reranking strategy: **WeightedRanker** and **RRFRanker**. When choosing a reranking strategy, one thing to consider is whether to there is any emphasis for one or more basic ANN search on the vector fields.â€‹

- **WeightedRanker**: This strategy is recommended if you require the results to emphasize a particular vector field. The WeightedRanker allows you to assign higher weights to certain vector fields, emphasizing them more. For instance, in multimodal searches, textual descriptions of an image might be considered more important than the colors in this image.â€‹

- **RRFRanker (Reciprocal Rank Fusion Ranker)**: This strategy is recommended when there is no specific emphasis. The RRF can effectively balance the importance of each vector field.â€‹

For more details about the mechanisms of these two reranking strategies, refer to [â€‹Reranking](https://zilliverse.feishu.cn/wiki/M4IYwThFKiatBkk0Cp3c9p4QnZc).â€‹

The following  two examples demonstrate how to use the WeightedRanker and RRFRanker reranking strategies:â€‹

1. **Example 1: Using WeightedRanker**â€‹

    When using the WeightedRanker strategy, you need to input weight values into the `WeightedRanker` function. The number of basic ANN searches in a Hybrid Search corresponds to the number of values that need to be inputted. The input values should be in the range [0,1], with values closer to 1 indicating greater importance.â€‹

    <Tabs><TabItem value="Python" label="python" default>

    ```Python
    from pymilvus import WeightedRankerâ€‹
    â€‹
    rerank= WeightedRanker(0.8, 0.3) â€‹

    ```    

</TabItem>

    <TabItem value="Java" label="java">

    ```Java
    import io.milvus.v2.service.vector.request.ranker.BaseRanker;â€‹
    import io.milvus.v2.service.vector.request.ranker.WeightedRanker;â€‹
    â€‹
    BaseRanker reranker = new WeightedRanker(Arrays.asList(0.8f, 0.3f));â€‹

    ```    

</TabItem>

    <TabItem value="JavaScript" label="Node.js">

    ```JavaScript
    import { MilvusClient, DataType } from "@zilliz/milvus2-sdk-node";â€‹
    â€‹
    const rerank = WeightedRanker(0.8, 0.3);â€‹

    ```    

</TabItem>

    <TabItem value="Bash" label="cURL">

    ```Bash
    export rerank='{â€‹
            "strategy": "ws",â€‹
            "params": {"weights": [0.8,0.3]}â€‹
        }'â€‹

    ```    

</TabItem></Tabs>

2. **Example 2: Using RRFRanker**â€‹

    When using the RRFRanker strategy, you need to input the parameter value `k` into the RRFRanker. The default value of `k` is 60. This parameter helps to determine how the ranks are combined from different ANN searches, aiming to balance and blend the importance across all searches.â€‹

    <Tabs><TabItem value="Python" label="python" default>

    ```Python
    from pymilvus import RRFRankerâ€‹
    â€‹
    ranker = RRFRanker(100)â€‹

    ```    

</TabItem>

    <TabItem value="Java" label="java">

    ```Java
    import io.milvus.v2.service.vector.request.ranker.BaseRanker;â€‹
    import io.milvus.v2.service.vector.request.ranker.RRFRanker;â€‹
    â€‹
    BaseRanker reranker = new RRFRanker(100);â€‹

    ```    

</TabItem>

    <TabItem value="JavaScript" label="Node.js">

    ```JavaScript
    import { MilvusClient, DataType } from "@zilliz/milvus2-sdk-node";â€‹
    â€‹
    const rerank = RRFRanker("100");â€‹

    ```    

</TabItem>

    <TabItem value="Bash" label="cURL">

    ```Bash
    export rerank='{â€‹
            "strategy": "rrf",â€‹
            "params": { "k": 100}â€‹
        }'â€‹

    ```    

</TabItem></Tabs>

### Perform a Hybrid Searchâ€‹{#perform-a-hybrid-searchâ€‹}

Before conducting a Hybrid Search, it is necessary to load the collection into memory. If any vector fields in the collection do not have an index or are not loaded, an error will occur when calling the Hybrid Search method. â€‹

<Tabs><TabItem value="Python" label="python" default>

```Python
from pymilvus import MilvusClientâ€‹
â€‹
res = client.hybrid_search(â€‹
    collection_name="hybrid_search_collection",â€‹
    reqs=reqs,â€‹
    ranker=ranker,â€‹
    limit=2â€‹
)â€‹
for hits in res:â€‹
    print("TopK results:")â€‹
    for hit in hits:â€‹
        print(hit)â€‹

```

</TabItem>

<TabItem value="Java" label="java">

```Java
import io.milvus.v2.common.ConsistencyLevel;â€‹
import io.milvus.v2.service.vector.request.HybridSearchReq;â€‹
import io.milvus.v2.service.vector.response.SearchResp;â€‹
â€‹
HybridSearchReq hybridSearchReq = HybridSearchReq.builder()â€‹
        .collectionName("hybrid_search_collection")â€‹
        .searchRequests(searchRequests)â€‹
        .ranker(reranker)â€‹
        .topK(2)â€‹
        .consistencyLevel(ConsistencyLevel.BOUNDED)â€‹
        .build();â€‹
â€‹
SearchResp searchResp = client.hybridSearch(hybridSearchReq);â€‹

```

</TabItem>

<TabItem value="JavaScript" label="Node.js">

```JavaScript
const { MilvusClient, DataType } = require("@zilliz/milvus2-sdk-node")â€‹
â€‹
res = await client.loadCollection({â€‹
    collection_name: "hybrid_search_collection"â€‹
})â€‹
â€‹
import { MilvusClient, RRFRanker, WeightedRanker } from '@zilliz/milvus2-sdk-node';â€‹
â€‹
const search = await client.search({â€‹
  collection_name: "hybrid_search_collection",â€‹
  data: [search_param_1, search_param_2],â€‹
  limit: 2,â€‹
  rerank: RRFRanker(100)â€‹
});â€‹

```

</TabItem>

<TabItem value="Bash" label="cURL">

```Bash
curl --request POST \â€‹
--url "${CLUSTER_ENDPOINT}/v2/vectordb/entities/advanced_search" \â€‹
--header "Authorization: Bearer ${TOKEN}" \â€‹
--header "Content-Type: application/json" \â€‹
-d "{â€‹
    \"collectionName\": \"hybrid_search_collection\",â€‹
    \"search\": ${req},â€‹
    \"rerank\": {â€‹
        \"strategy\":\"rrf\",â€‹
        \"params\": {â€‹
            \"k\": 10â€‹
        }â€‹
    },â€‹
    \"limit\": 3,â€‹
    \"outputFields\": [â€‹
        \"user_id\",â€‹
        \"word_count\",â€‹
        \"book_describe\"â€‹
    ]â€‹
}"â€‹

```

</TabItem></Tabs>

The following is the output:â€‹

```Python
["['id: 844, distance: 0.006047376897186041, entity: {}', 'id: 876, distance: 0.006422005593776703, entity: {}']"]â€‹

```

Since `limit=2` is specified in the Hybrid Search, Zilliz will rerank the four search results from step 3 and ultimately return only the top 2 most similar search results. â€‹




